---
title: "Graph clustering with SBM"
author: "Etienne CÃ´me"
date: "`r Sys.Date()`"
fig_caption: yes
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Graph clustering with SBM}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```


Loads packages and set a future plan for parallel processing.
```{r}
library(future)
library(Matrix)
library(ggplot2)
library(greed)
library(dplyr)
plan(multisession)
```

Simulation of an SBM graph with a hierarchical structure.
```{r, fig.show='hold'}
N=1500
K=15
pi=rep(1/K,K)
lambda  = 0.1
lambda_o = 0.01
Ks=5
mu = bdiag(lapply(1:(K/Ks), function(k){matrix(lambda_o,Ks,Ks)+diag(rep(lambda,Ks))}))+0.001
sbm = rsbm(N,pi,mu)
```

Perform the clustering with default model and algorithm. We specify to choose an sbm model since for squared sparse matrix the default is a dc-sbm model. An hybrid  algorithm is selected by default and the default value for the parameter K is 20.

```{r}
sol = greed(sbm$x,model=new("sbm"))
```
Plot the results using a block representation.

```{r, fig.show='hold',out.width="70%",fig.width=8,fig.height=5.5}
plot(sol,type='blocks')
```

Improvement of the hybrid algorithm with respect to multiple start is clearly visible :

```{r, fig.show='hold',out.width="70%",fig.width=8,fig.height=5.5}
ggplot()+geom_boxplot(data=sol@train_hist,aes(x=generation,group=generation,y=icl))
```

```{r, fig.show='hold',out.width="70%",fig.width=8,fig.height=5.5}
ggplot()+geom_line(data=sol@train_hist %>% group_by(generation) %>% summarise(K=mean(K)),aes(x=generation,y=K))+
  geom_point(data=sol@train_hist %>% group_by(generation,K) %>% summarise(n=n()),aes(x=generation,y=K,size=n))
```


Plot the results with a node link diagram.
```{r, fig.show='hold',out.width="70%",fig.width=8,fig.height=5.5}
plot(sol,type='nodelink')
```
Or a dendogram for selecting a smaller value for K.
```{r, fig.show='hold',out.width="70%",fig.width=8,fig.height=5.5}
plot(sol,type='tree')
```
Eventually study the evolution of $-log(\alpha)$ with respect to $K$.
```{r, fig.show='hold',out.width="70%",fig.width=8,fig.height=5.5}
plot(sol,type='path')
```

Or of ICL with respect to $log(\alpha)$
```{r, fig.show='hold',out.width="70%",fig.width=8,fig.height=5.5}
plot(sol,type='front')
```

And select a smaller value to extract a new solution.
```{r, fig.show='hold',out.width="70%",fig.width=8,fig.height=5.5}
sol3 = cut(sol,3)
plot(sol3,type='blocks')
```

Other model are availbale dscbm, mm
```{r, fig.show='hold',out.width="70%",fig.width=8,fig.height=5.5}
soldc = greed(sbm$x,25,new("dcsbm"))
plot(soldc,type='blocks')
```

Eventualy you may change the algorithm "hybrid" (default), "multistart" for greedy with random multiple start and "seed"" for greedy initialized with spectral clustering. See the doc for details on the algorithm parameters. 

One example with the polbooks dataset:
```{r, fig.show='hold',out.width="70%",fig.width=8,fig.height=5.5}
data("Xpolbooks")
solpol=greed(Xpolbooks,10,new("dcsbm"),new("hybrid",pop_size=30))
plot(solpol,type='blocks')
```


```{r, fig.show='hold',out.width="70%",fig.width=8,fig.height=5.5}
data("Lpolbooks")
plot(solpol,type='tree')
table(Lpolbooks,cut(solpol,3)@cl)
```


One with the polblogs dataset:
```{r, fig.show='hold',out.width="70%",fig.width=8,fig.height=5.5}
data("Xpolblogs")
solblogs=greed(Xpolblogs)
plot(solblogs,type='blocks')
```

```{r, fig.show='hold',out.width="70%",fig.width=8,fig.height=5.5}
data("Lpolblogs")
plot(solblogs,type='front')
table(Lpolblogs,cut(solblogs,2)@cl)
```
```{r, fig.show='hold',out.width="70%",fig.width=8,fig.height=5.5}
data("Xfoot")
solfoot=greed(Xfoot)
plot(solfoot,type='blocks')
```