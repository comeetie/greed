---
title: "Graph clustering with SBM"
author: "Etienne CÃ´me"
date: "`r Sys.Date()`"
fig_caption: yes
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Graph clustering with SBM}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```


Loads packages and set a future plan for parallel processing.
```{r}
library(future)
library(Matrix)
library(ggplot2)
library(greed)
plan(multicore)
```

Simulation of an SBM graph with a hierarchical structure.
```{r, fig.show='hold'}
N=800
K=8
pi=rep(1/K,K)
lambda  = 0.1
lambda_o = 0.01
Ks=4
mu = bdiag(lapply(1:(K/Ks), function(k){matrix(lambda_o,Ks,Ks)+diag(rep(lambda,Ks))}))+0.001
sbm = rsbm(N,pi,mu)
```

Perform the clustering with default model and algorithm. We specify to choose an sbm model since for squared sparse matrix the default is a dc-sbm model. An hybrid  algorithm is selected by default and the default value for the parameter K is 20.

```{r}
sol = greed(sbm$x,model=new("sbm"))
```
Plot the results using a block representation.

```{r, fig.show='hold',out.width="70%",fig.width=8,fig.height=5.5}
plot(sol,type='blocks')
```



Plot the results with a node link diagram.
```{r, fig.show='hold',out.width="70%",fig.width=8,fig.height=5.5}
plot(sol,type='nodelink')
```

Or a dendrogram for selecting a smaller value for K.
```{r, fig.show='hold',out.width="70%",fig.width=8,fig.height=5.5}
plot(sol,type='tree')
```

Eventually study the evolution of $-log(\alpha)$ with respect to $K$.
```{r, fig.show='hold',out.width="70%",fig.width=8,fig.height=5.5}
plot(sol,type='path')
```

Or of ICL with respect to $log(\alpha)$
```{r, fig.show='hold',out.width="70%",fig.width=8,fig.height=5.5}
plot(sol,type='front')
```

And select a smaller value to extract a new solution.
```{r, fig.show='hold',out.width="70%",fig.width=8,fig.height=5.5}
sol2 = cut(sol,2)
plot(sol2,type='blocks')
```


Eventually, you may change the algorithm from **hybrid** (default) to **multistart** for greedy with random multiple starts or **seed** for greedy initialized with spectral clustering. See the doc for details on the algorithm parameters. 

One example with the polbooks dataset:
```{r, fig.show='hold',out.width="70%",fig.width=8,fig.height=5.5}
data("Books")
solbooks=greed(Books$X,10,new("dcsbm"),new("hybrid",pop_size=30))
plot(solbooks,type='blocks')
```


```{r, fig.show='hold',out.width="70%",fig.width=8,fig.height=5.5}
plot(solbooks,type='tree')
table(Books$label,cut(solbooks,3)@cl)
```


One with the polblogs dataset:
```{r, fig.show='hold',out.width="70%",fig.width=8,fig.height=5.5}
data("Blogs")
solblogs=greed(Blogs$X)
plot(solblogs,type='blocks')
```

```{r, fig.show='hold',out.width="70%",fig.width=8,fig.height=5.5}
plot(solblogs,type='front')
table(Blogs$label,cut(solblogs,2)@cl)
```
```{r, fig.show='hold',out.width="70%",fig.width=8,fig.height=5.5}
data("Football")
solfoot=greed(Football$X)
plot(solfoot,type='blocks')
```