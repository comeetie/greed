best_icl = max(icls)
nbgen = nbgen + 1;
}
train.hist=rbind(train.hist,data.frame(generation=nbgen,icl=icls,K=sapply(solutions,function(s){max(s@cl)})))
#parallel::stopCluster(cl)
# best solution
res = solutions[[order(icls,decreasing = TRUE)[1]]]
# compute merge path
path = fit_greed_path(x,res)
# clean the resuts (compute, merge tree,...)
path = cleanpath(path)
# store train history
path@train_hist = train.hist
# stop future plan
#oplan <- future::plan()
#on.exit(future::plan(oplan), add = TRUE)
path
}
hybrid(f,fi,5,new("mreg"))
hybrid = function(f,fi, K,alg,model,verbose=FALSE){
train.hist = data.frame(generation=c(),icl=c(),K=c())
# multi-start in //
#future::plan(future::multiprocess)
solutions = listenv::listenv()
# first generation of solutions
pop_size = alg@pop_size
for (i in 1:pop_size){
solutions[[i]] %<-% f(model,K,verbose=verbose)
}
solutions = as.list(solutions)
icls  = sapply(solutions,function(s){s@icl})
# check for errors
solutions=solutions[!is.nan(icls)]
icls=icls[!is.nan(icls)]
old_best = -Inf
best_icl = max(icls)
nbgen = 1
# while maximum number of generation // all solutions are equals // no improvements
while((max(icls)-min(icls))>1 & (best_icl > old_best) & nbgen < alg@nb_max_gen){
train.hist=rbind(train.hist,data.frame(generation=nbgen,icl=icls,K=sapply(solutions,function(s){max(s@cl)})))
# selection keep the top half solutions
icl_order = order(icls,decreasing = TRUE)
selected  = icl_order[1:(pop_size/2)]
# cross_over between the kept solution
new_solutions = listenv::listenv()
selected_couples = matrix(selected[sample(1:length(selected),length(selected)*2,replace = TRUE)],ncol=2)
for (i in 1:nrow(selected_couples)){
new_solutions[[i]] %<-% full_cross_over(solutions[[selected_couples[i,1]]],solutions[[selected_couples[i,2]]],model,x,verbose)
}
new_solutions = as.list(new_solutions)
solutions = c(solutions[selected],new_solutions)
icls = sapply(solutions,function(s){s@icl})
old_best=best_icl
best_icl = max(icls)
nbgen = nbgen + 1;
}
train.hist=rbind(train.hist,data.frame(generation=nbgen,icl=icls,K=sapply(solutions,function(s){max(s@cl)})))
#parallel::stopCluster(cl)
# best solution
res = solutions[[order(icls,decreasing = TRUE)[1]]]
# compute merge path
path = fit_greed_path(x,res)
# clean the resuts (compute, merge tree,...)
path = cleanpath(path)
# store train history
path@train_hist = train.hist
# stop future plan
#oplan <- future::plan()
#on.exit(future::plan(oplan), add = TRUE)
path
}
hybrid(f,fi,5,new("hybrid"),new("mreg"))
library(future)
hybrid(f,fi,5,new("hybrid"),new("mreg"))
hybrid(f,fi,5,new("hybrid"),new("mreg"),TRUE)
f(new("mreg"),5,TRUE)
f(new("mreg"),5)
f(new("mreg"),5,TRUE)
X=mreg_simu$X
y=mreg_simu$y
f = function(model,k,verb){
fit_greed_cond(model,X,y,k,verb)
}
f(new("mreg"),5,TRUE)
X
X=mreg_simu$X
y=mreg_simu$y
f = function(model,k,verb){
fit_greed_cond(model,X,y,k,verbose=verb)
}
fi = function(model,cl,k,verb){
fit_greed_init_cond(model,X,y,cl,verbose=verb)
}
f(new("mreg"),5,TRUE)
f(new("mreg"),5,TRUE)
devtools::document()
library(greed)
library(Matrix)
library(ggplot2)
N=1500
K=15
pi=rep(1/K,K)
lambda  = 0.1
lambda_o = 0.01
Ks=5
mu = bdiag(lapply(1:(K/Ks), function(k){matrix(lambda_o,Ks,Ks)+diag(rep(lambda,Ks))}))+0.001
sbm = rsbm(N,pi,mu)
sol = fit(sbm$x,25)
library(greed)
sol = fit(sbm$x,25)
#' @describeIn fit
#' @title Fit a clustering model
#'
#' @param x A sparse Matrix as a \code{dgCMatrix}
#' @param K An initial guess of the maximal number of cluster
#' @param model An \code{\link{IclModel-class}} such as \code{\link{sbm-class}}, \code{\link{dcsbm-class}}, ...
#' @param alg An optimization algorithm such as \code{\link{greed-class}}, \code{\link{genetic-class}} or \code{\link{km-class}}
#' @export
setGeneric("fit",function(X,y,K,model,alg))
#' @describeIn fit
#' @title Fit a clustering model
#'
#' @param x A sparse Matrix as a \code{dgCMatrix}
#' @param K An initial guess of the maximal number of cluster
#' @param model An \code{\link{IclModel-class}} such as \code{\link{sbm-class}}, \code{\link{dcsbm-class}}, ...
#' @param alg An optimization algorithm such as \code{\link{greed-class}}, \code{\link{genetic-class}} or \code{\link{km-class}}
#' @export
setGeneric("fit",function(X,y,K,model,alg){})
#' @describeIn fit
#' @export
setMethod(f = "fit",
signature = signature("dgCMatrix", "missing", "numeric","icl_model", "missing"),
definition = function(x,K,model,verbose=FALSE){
fit(x,K,model,new("hybrid"),verbose=verbose)
});
#' @describeIn fit
#' @export
setMethod(f = "fit",
signature = signature("dgCMatrix", "missing", "numeric","missing","missing"),
definition = function(x,K,verbose=FALSE){
# only a sparseMatrix and a number check dim to choose between graph models and mm
if(dim(x)[1]==dim(x)[2]){
fit(x,K,new("dcsbm"),new("hybrid"),verbose=verbose)
}else{
fit(x,K,new("mm"),new("hybrid"),verbose=verbose)
}
});
library(Matrix)
#' @describeIn fit
#' @export
setMethod(f = "fit",
signature = signature("dgCMatrix", "missing", "numeric","missing","missing"),
definition = function(x,K,verbose=FALSE){
# only a sparseMatrix and a number check dim to choose between graph models and mm
if(dim(x)[1]==dim(x)[2]){
fit(x,K,new("dcsbm"),new("hybrid"),verbose=verbose)
}else{
fit(x,K,new("mm"),new("hybrid"),verbose=verbose)
}
});
#' @describeIn fit
#' @title Fit a clustering model
#'
#' @param x A sparse Matrix as a \code{dgCMatrix}
#' @param K An initial guess of the maximal number of cluster
#' @param model An \code{\link{IclModel-class}} such as \code{\link{sbm-class}}, \code{\link{dcsbm-class}}, ...
#' @param alg An optimization algorithm such as \code{\link{greed-class}}, \code{\link{genetic-class}} or \code{\link{km-class}}
#' @export
setGeneric("fit",function(x,y,K,model,alg){})
#' @describeIn fit
#' @export
setMethod(f = "fit",
signature = signature("dgCMatrix", "missing", "numeric","missing","missing"),
definition = function(x,K,verbose=FALSE){
# only a sparseMatrix and a number check dim to choose between graph models and mm
if(dim(x)[1]==dim(x)[2]){
fit(x,K,new("dcsbm"),new("hybrid"),verbose=verbose)
}else{
fit(x,K,new("mm"),new("hybrid"),verbose=verbose)
}
});
#' @describeIn fit
#' @title Fit a clustering model
#'
#' @param x A sparse Matrix as a \code{dgCMatrix}
#' @param K An initial guess of the maximal number of cluster
#' @param model An \code{\link{IclModel-class}} such as \code{\link{sbm-class}}, \code{\link{dcsbm-class}}, ...
#' @param alg An optimization algorithm such as \code{\link{greed-class}}, \code{\link{genetic-class}} or \code{\link{km-class}}
#' @export
setGeneric("fit",function(x,y,K,model,alg){})
#' @describeIn fit
#' @export
setMethod(f = "fit",
signature = signature("dgCMatrix", "numeric","missing","missing","missing"),
definition = function(x,K,verbose=FALSE){
# only a sparseMatrix and a number check dim to choose between graph models and mm
if(dim(x)[1]==dim(x)[2]){
fit(x,K,new("dcsbm"),new("hybrid"),verbose=verbose)
}else{
fit(x,K,new("mm"),new("hybrid"),verbose=verbose)
}
});
#' @describeIn fit
#' @export
setMethod(f = "fit",
signature = signature("dgCMatrix", "numeric"),
definition = function(x,K,verbose=FALSE){
# only a sparseMatrix and a number check dim to choose between graph models and mm
if(dim(x)[1]==dim(x)[2]){
fit(x,K,new("dcsbm"),new("hybrid"),verbose=verbose)
}else{
fit(x,K,new("mm"),new("hybrid"),verbose=verbose)
}
});
#' @describeIn fit
#' @title Fit a clustering model
#'
#' @param x A sparse Matrix as a \code{dgCMatrix}
#' @param K An initial guess of the maximal number of cluster
#' @param model An \code{\link{IclModel-class}} such as \code{\link{sbm-class}}, \code{\link{dcsbm-class}}, ...
#' @param alg An optimization algorithm such as \code{\link{greed-class}}, \code{\link{genetic-class}} or \code{\link{km-class}}
#' @export
setGeneric("fit",function(x,y,K,model,alg,...){})
#' @describeIn fit
#' @export
setMethod(f = "fit",
signature = signature("dgCMatrix", "numeric"),
definition = function(x,K,verbose=FALSE){
# only a sparseMatrix and a number check dim to choose between graph models and mm
if(dim(x)[1]==dim(x)[2]){
fit(x,K,new("dcsbm"),new("hybrid"),verbose=verbose)
}else{
fit(x,K,new("mm"),new("hybrid"),verbose=verbose)
}
});
#' @describeIn fit
#' @export
setMethod(f = "fit",
signature = signature("dgCMatrix", "numeric","missing","missing"),
definition = function(x,K,verbose=FALSE){
# only a sparseMatrix and a number check dim to choose between graph models and mm
if(dim(x)[1]==dim(x)[2]){
fit(x,K,new("dcsbm"),new("hybrid"),verbose=verbose)
}else{
fit(x,K,new("mm"),new("hybrid"),verbose=verbose)
}
});
#' @describeIn fit
#' @title Fit a clustering model
#'
#' @param x A sparse Matrix as a \code{dgCMatrix}
#' @param K An initial guess of the maximal number of cluster
#' @param model An \code{\link{IclModel-class}} such as \code{\link{sbm-class}}, \code{\link{dcsbm-class}}, ...
#' @param alg An optimization algorithm such as \code{\link{greed-class}}, \code{\link{genetic-class}} or \code{\link{km-class}}
#' @export
setGeneric("fit",function(x,...){})
#' @describeIn fit
#' @title Fit a clustering model
#'
#' @param x A sparse Matrix as a \code{dgCMatrix}
#' @param K An initial guess of the maximal number of cluster
#' @param model An \code{\link{IclModel-class}} such as \code{\link{sbm-class}}, \code{\link{dcsbm-class}}, ...
#' @param alg An optimization algorithm such as \code{\link{greed-class}}, \code{\link{genetic-class}} or \code{\link{km-class}}
#' @export
setGeneric("fit",function(x,...){})
#' @describeIn fit
#' @export
setMethod(f = "fit",
signature = signature("dgCMatrix", "numeric"),
definition = function(x,K,verbose=FALSE){
# only a sparseMatrix and a number check dim to choose between graph models and mm
if(dim(x)[1]==dim(x)[2]){
fit(x,K,new("dcsbm"),new("hybrid"),verbose=verbose)
}else{
fit(x,K,new("mm"),new("hybrid"),verbose=verbose)
}
});
#' @describeIn fit
#' @title Fit a clustering model
#'
#' @param x A sparse Matrix as a \code{dgCMatrix}
#' @param K An initial guess of the maximal number of cluster
#' @param model An \code{\link{IclModel-class}} such as \code{\link{sbm-class}}, \code{\link{dcsbm-class}}, ...
#' @param alg An optimization algorithm such as \code{\link{greed-class}}, \code{\link{genetic-class}} or \code{\link{km-class}}
#' @export
setGeneric("fit",function(x,...) standardGeneric("fit"))
#' @describeIn fit
#' @export
setMethod(f = "fit",
signature = signature("dgCMatrix", "numeric"),
definition = function(x,K,verbose=FALSE){
# only a sparseMatrix and a number check dim to choose between graph models and mm
if(dim(x)[1]==dim(x)[2]){
fit(x,K,new("dcsbm"),new("hybrid"),verbose=verbose)
}else{
fit(x,K,new("mm"),new("hybrid"),verbose=verbose)
}
});
#' @describeIn fit
#' @title Fit a clustering model
#'
#' @param x A sparse Matrix as a \code{dgCMatrix}
#' @param K An initial guess of the maximal number of cluster
#' @param model An \code{\link{IclModel-class}} such as \code{\link{sbm-class}}, \code{\link{dcsbm-class}}, ...
#' @param alg An optimization algorithm such as \code{\link{greed-class}}, \code{\link{genetic-class}} or \code{\link{km-class}}
#' @export
setGeneric("fit",function(model,alg,...) standardGeneric("fit"))
#' @describeIn fit
#' @export
setMethod(f = "fit",
signature = signature("icl_model","hybrid"),
definition = function(model,alg,x, K,verbose=FALSE){
f = function(){
fit_greed(model,x,K,verbose = verbose)
}
fi = function(ncl){
fit_greed_init(model,x,ncl,verbose = verbose)
}
fp = function(sol){
fit_greed_path(x,sol)
}
hybrid(f,fi,fp,alg,verbose)
})
#' @title Clustering models classes
#' @aliases icl_model icl_model-class sbm sbm-class mm mm-class
#' @name models-classes
NULL
source('~/Projets/greed/R/models_classes.R')
#' @useDynLib greed
#' @importFrom Rcpp sourceCpp
#' @importFrom future %<-%
#' @name %<-%
NULL
#' @include models_classes.R fit_classes.R hybrid_alg.R genetic_alg.R
#' @import Matrix
NULL
#' @title Optimization algorithm classes
#'
#' @name algs-classes
NULL
#' @rdname algs-classes
#' @title alg
#' An S4 class to represent an abstract optimisation algorithm.
#' @slot name Name of the algorithm
#' @export
setClass("alg",slots = list(name = "character"))
#' @rdname algs-classes
#' @title gree
#' An S4 class to represent a greedy algorithm extends \code{alg} class with multiple start.
#' @slot nb_start number of random starts (default to 10)
#' @export
setClass("greed",
contains = "alg",
representation =  list(nb_start="numeric"),
prototype(name="greed",nb_start=10))
#' @rdname algs-classes
#' @title km
#' An S4 class to represent a greedy algorithm extends \code{alg} class with initialization with spectral clustering and or k-means.
#' @export
setClass("seed",
contains = "alg",
representation =  list(),
prototype(name="seed"))
#' @rdname algs-classes
#' @title genetic
#' An S4 class to represent a hybrid genetic/greedy algorithm extends \code{alg} class.
#' @slot pop_size size of the solutions populations (default to 10)
#' @slot nb_max_gen maximal number of generation to produce (default to 4)
#' @export
setClass("hybrid",
contains = "alg",
representation =  list(pop_size = "numeric",nb_max_gen = "numeric"),
prototype(name="hybrid",pop_size=10, nb_max_gen = 10))
#' @rdname algs-classes
#' @title genetic
#' An S4 class to represent a hybrid genetic/greedy algorithm extends \code{alg} class.
#' @slot pop_size size of the solutions populations (default to 10)
#' @slot nb_max_gen maximal number of generation to produce (default to 4)
#' @export
setClass("genetic",
contains = "alg",
representation =  list(pop_size = "numeric",nb_max_gen = "numeric",prob_mut="numeric",sel_frac="numeric"),
prototype(name="genetic",pop_size=100, nb_max_gen = 20,prob_mut=0.1,sel_frac=0.75))
#' @describeIn fit
#' @export
setMethod(f = "fit",
signature = signature("icl_model","hybrid"),
definition = function(model,alg,x, K,verbose=FALSE){
f = function(){
fit_greed(model,x,K,verbose = verbose)
}
fi = function(ncl){
fit_greed_init(model,x,ncl,verbose = verbose)
}
fp = function(sol){
fit_greed_path(x,sol)
}
hybrid(f,fi,fp,alg,verbose)
})
#' @describeIn fit
#' @title Fit a clustering model
#'
#' @param x A sparse Matrix as a \code{dgCMatrix}
#' @param K An initial guess of the maximal number of cluster
#' @param model An \code{\link{IclModel-class}} such as \code{\link{sbm-class}}, \code{\link{dcsbm-class}}, ...
#' @param alg An optimization algorithm such as \code{\link{greed-class}}, \code{\link{genetic-class}} or \code{\link{km-class}}
#' @export
setGeneric("fit",function(model,alg,...) standardGeneric("fit"))
#' @describeIn fit
#' @export
setMethod(f = "fit",
signature = signature("icl_model","hybrid"),
definition = function(model,alg,x, K,verbose=FALSE){
f = function(){
fit_greed(model,x,K,verbose = verbose)
}
fi = function(ncl){
fit_greed_init(model,x,ncl,verbose = verbose)
}
fp = function(sol){
fit_greed_path(x,sol)
}
hybrid(f,fi,fp,alg,verbose)
})
#' @describeIn fit
#' @export
setMethod(f = "fit",
signature = signature("icl_model","missing"),
definition = function(model,x, K=20,verbose=FALSE){
fit(model,new("hybrid"),x,K,verbose)
})
#' @describeIn fit
#' @export
setMethod(f = "fit",
signature = signature("icl_model","missing"),
definition = function(model,x, K=20,verbose=FALSE){
fit(model,new("hybrid"),x,K,verbose)
})
#' @describeIn fit
#' @export
setMethod(f = "fit",
signature = signature("icl_model","hybrid"),
definition = function(model,alg,x, K,verbose=FALSE){
f = function(){
fit_greed(model,x,K,verbose = verbose)
}
fi = function(ncl){
fit_greed_init(model,x,ncl,verbose = verbose)
}
fp = function(sol){
fit_greed_path(x,sol)
}
hybrid(f,fi,fp,alg,verbose)
})
#' @describeIn fit
#' @export
setMethod(f = "fit",
signature = signature("icl_model","genetic"),
definition = function(model,alg,x,k,verbose=FALSE){
init_f = function(cl){
init(model,x,cl)
}
greed_f = function(ncl,type="both",nb_pass=1){
fit_greed_init(model,x,ncl,type,nb_pass,verbose = verbose)
}
path_f = function(sol){
fit_greed_path(x,sol)
}
genetic(x,init_f,greed_f,path_f,alg,verbose=FALSE)
})
#' @describeIn fit
#' @export
setMethod(f = "fit",
signature = signature("icl_model","greed"),
definition = function(model,alg,x, K=20,verbose=FALSE){
greed_f = function(ncl){
fit_greed(model,x,K,verbose = verbose)
}
path_f = function(sol){
fit_greed_path(x,sol)
}
multistart(greed_f,path_f,alg,verbose=FALSE)
})
#' @describeIn fit
#' @export
setMethod(f = "fit",
signature = signature("icl_model","seed"),
definition = function(model,alg,x, K=20,verbose=FALSE){
if(class(model)=="dcsbm" | class(model)=="sbm"){
cl = spectral(x,K)
}
if(class(model)=="mm"){
cl = kmeans(x,K)
}
res = fit_greed_init(model,x,cl,"both",verbose=verbose)
path = fit_greed_path(x,res)
p=cleanpath(path)
})
#' @describeIn fit
#' @export
setMethod(f = "fit",
signature = signature("dgCMatrix", "numeric"),
definition = function(x,K,verbose=FALSE){
# only a sparseMatrix and a number check dim to choose between graph models and mm
if(dim(x)[1]==dim(x)[2]){
fit(x,K,new("dcsbm"),new("hybrid"),verbose=verbose)
}else{
fit(x,K,new("mm"),new("hybrid"),verbose=verbose)
}
});
source('~/Projets/greed/R/alg_classes.R')
source('~/Projets/greed/R/alg_classes.R')
