b
a
st=sK1
-st$a*log(st$b)
st=sK21
-st$a*log(st$b)
sK22=lm_post(mreg_simu$X[mreg_simu$cl==2,],mreg_simu$y[mreg_simu$cl==2],5,1,1)
sK21=lm_post(mreg_simu$X[mreg_simu$cl==1,],mreg_simu$y[mreg_simu$cl==1],5,1,1)
sK1=lm_post(mreg_simu$X,mreg_sim$y,5,1,1)
sK1=lm_post(mreg_simu$X,mreg_simu$y,5,1,1)
sK1$log_evidence
sK21$log_evidence+sK22$log_evidence
-0.5*2*log(5)
-0.5*2*log(0.1)
s=sK1
det(s$S)
s=sK21
det(s$S)
library(greed)
sK21=lm_post(mreg_simu$X[mreg_simu$cl==1,],mreg_simu$y[mreg_simu$cl==1],5,1,1)
sK22=lm_post(mreg_simu$X[mreg_simu$cl==2,],mreg_simu$y[mreg_simu$cl==2],5,1,1)
sK1=lm_post(mreg_simu$X,mreg_simu$y,5,1,1)
sK1$log_evidence
sK21$log_evidence+sK22$log_evidence
sol=fit_greed_cond(new("mreg",mreg_simu$X,mreg_simu$y),5)
sol=fit_greed_cond(new("mreg"),mreg_simu$X,mreg_simu$y,5)
table(sol@cl,mreg_simu$cl)
sol=fit_greed_cond(new("mreg"),mreg_simu$X,mreg_simu$y,5)
table(sol@cl,mreg_simu$cl)
sol=fit_greed_cond(new("mreg"),mreg_simu$X,mreg_simu$y,5,verbose = TRUE)
library(greed)
sol=fit_greed_cond(new("mreg"),mreg_simu$X,mreg_simu$y,5,verbose = TRUE)
table(sol@cl,mreg_simu$cl)
library(greed)
sol=fit_greed_cond(new("mreg"),mreg_simu$X,mreg_simu$y,5,verbose = TRUE)
table(sol@cl,mreg_simu$cl)
sol=fit_greed_init_cond(new("mreg"),mreg_simu$X,mreg_simu$y,mreg_simu$cl,verbose = TRUE)
table(sol@cl,mreg_simu$cl)
devtools::document()
sK21=lm_post(mreg_simu$X[mreg_simu$cl==1,],mreg_simu$y[mreg_simu$cl==1],5,1,1)
sK22=lm_post(mreg_simu$X[mreg_simu$cl==2,],mreg_simu$y[mreg_simu$cl==2],5,1,1)
sKm = lm_post_
sKm = lm_post_merge(sK21,sK22,5,1,1)
sK1=lm_post(mreg_simu$X,mreg_simu$y,5,1,1)
sK1$log_evidence
sK21$log_evidence+sK22$log_evidence
sKm$log_evidence
reg=0.1
sK21=lm_post(mreg_simu$X[mreg_simu$cl==1,],mreg_simu$y[mreg_simu$cl==1],reg,1,1)
sK22=lm_post(mreg_simu$X[mreg_simu$cl==2,],mreg_simu$y[mreg_simu$cl==2],reg,1,1)
sKm = lm_post_merge(sK21,sK22,reg,1,1)
sK1=lm_post(mreg_simu$X,mreg_simu$y,reg,1,1)
sK1$log_evidence
sK21$log_evidence+sK22$log_evidence
sKm$log_evidence
sK21$log_evidence+sK22$log_evidence
skadd = lm_post_add(sK21,mreg_simu$X[mreg_simu$cl==2,],mreg_simu$y[mreg_simu$cl==2],reg,1,1)
skadd$log_evidence
skadd = lm_post_add(sK21,mreg_simu$X[mreg_simu$cl==2,],mreg_simu$y[mreg_simu$cl==2],reg,1,1)
skadd$log_evidence
skdel = lm_post_del(sadd,mreg_simu$X[mreg_simu$cl==2,],mreg_simu$y[mreg_simu$cl==2],reg,1,1)
skdel = lm_post_del(skadd,mreg_simu$X[mreg_simu$cl==2,],mreg_simu$y[mreg_simu$cl==2],reg,1,1)
skdel$log_evidence
sK21$log_evidence
sol=fit_greed_init_cond(new("mreg"),mreg_simu$X,mreg_simu$y,mreg_simu$cl,verbose = TRUE)
table(sol@cl,mreg_simu$cl)
sol=fit_greed_init_cond(new("mreg"),mreg_simu$X,mreg_simu$y,mreg_simu$cl,type = "swap",verbose = TRUE)
table(sol@cl,mreg_simu$cl)
sol=fit_greed_init_cond(new("mreg"),mreg_simu$X,mreg_simu$y,mreg_simu$cl,type = "swap",verbose = TRUE)
table(sol@cl,mreg_simu$cl)
cl=mreg_simu$cl
cl[smaple(1000,50)]=1
cl[smaple(1000,50)]=2
cl[smaple(1000,150)]=3
cl[sample(1000,50)]=1
cl[sample(1000,50)]=2
cl[sample(1000,150)]=3
sol=fit_greed_init_cond(new("mreg"),mreg_simu$X,mreg_simu$y,cl,type = "swap",verbose = TRUE)
table(sol@cl,mreg_simu$cl)
cl=mreg_simu$cl
cl[sample(1000,50)]=1
cl[sample(1000,50)]=2
cl[sample(1000,150)]=3
sol=fit_greed_init_cond(new("mreg"),mreg_simu$X,mreg_simu$y,cl,type = "swap",verbose = TRUE)
table(sol@cl,mreg_simu$cl)
library(greed)
sol=fit_greed_cond(new("mreg"),mreg_simu$X,mreg_simu$y,verbose = TRUE)
sol=fit_greed_cond(new("mreg"),mreg_simu$X,mreg_simu$y,5,verbose = TRUE)
table(sol@cl,mreg_simu$cl)
sol=fit_greed_cond(new("mreg"),mreg_simu$X,mreg_simu$y,5,verbose = TRUE)
table(sol@cl,mreg_simu$cl)
sol=fit_greed_cond(new("mreg"),mreg_simu$X,mreg_simu$y,5,verbose = TRUE)
table(sol@cl,mreg_simu$cl)
sol=fit_greed_cond(new("mreg"),mreg_simu$X,mreg_simu$y,5,verbose = TRUE)
table(sol@cl,mreg_simu$cl)
sol=fit_greed_cond(new("mreg",alpha=1,a0=1,b0=1,reg=5),mreg_simu$X,mreg_simu$y,5,verbose = TRUE)
table(sol@cl,mreg_simu$cl)
sol=fit_greed_cond(new("mreg",alpha=1,a0=1,b0=1,reg=5),mreg_simu$X,mreg_simu$y,5,verbose = TRUE)
table(sol@cl,mreg_simu$cl)
sol=fit_greed_cond(new("mreg",alpha=1,a0=1,b0=1,reg=5),mreg_simu$X,mreg_simu$y,5,verbose = TRUE)
table(sol@cl,mreg_simu$cl)
sol=fit_greed_cond(new("mreg",alpha=1,a0=1,b0=1,reg=1),mreg_simu$X,mreg_simu$y,5,verbose = TRUE)
table(sol@cl,mreg_simu$cl)
sol=fit_greed_cond(new("mreg",alpha=1,a0=1,b0=1,reg=1),mreg_simu$X,mreg_simu$y,5,verbose = TRUE)
table(sol@cl,mreg_simu$cl)
sol=fit_greed_cond(new("mreg",alpha=1,a0=1,b0=1,reg=1),mreg_simu$X,mreg_simu$y,5,verbose = TRUE)
table(sol@cl,mreg_simu$cl)
sol=fit_greed_init_cond(new("mreg"),mreg_simu$X,mreg_simu$y,mreg_simu$cl,type = "swap")
sol=fit_greed_init_cond(new("mreg"),mreg_simu$X,mreg_simu$y,mreg_simu$cl,type = "both",verbose = TRUE)
tcf=table(sol@cl,mreg_simu$cl)
tcf
apply(tcf,1,min)
sum(apply(tcf,1,min))
sol=fit_greed_cond(new("mreg",alpha=1,a0=1,b0=1,reg=1),mreg_simu$X,mreg_simu$y,5,verbose = TRUE)
tcf= table(sol@cl,mreg_simu$cl)
nb_malcl = sum(apply(tcf,1,min))
expect_lte(nb_malcl,  100)
devtools::test()
devtools::test()
devtools::test()
devtools::test()
devtools::test()
sol=fit_greed_cond(new("mreg",alpha=1,a0=1,b0=1,reg=1),mreg_simu$X,mreg_simu$y,5,verbose = TRUE)
sol=fit_greed_cond(new("mreg",alpha=1,a0=1,b0=1,reg=1),mreg_simu$X,mreg_simu$y,5,verbose = TRUE)
sol=fit_greed_cond(new("mreg",alpha=1,a0=1,b0=1,reg=1),mreg_simu$X,mreg_simu$y,5,verbose = TRUE)
sol=fit_greed_cond(new("mreg",alpha=1,a0=1,b0=1,reg=1),mreg_simu$X,mreg_simu$y,5,verbose = TRUE)
sol=fit_greed_cond(new("mreg",alpha=1,a0=1,b0=1,reg=1),mreg_simu$X,mreg_simu$y,5,verbose = TRUE)
tcf=table(sol@cl,mreg_simu$cl)
tcf
plot(mreg_simu$X[,1],mreg_simu$y,col=c("#ff4444","#44ff44")[sol@cl])
sol=fit_greed_cond(new("mreg",alpha=1,a0=1,b0=1,reg=1),mreg_simu$X,mreg_simu$y,5,verbose = TRUE)
plot(mreg_simu$X[,1],mreg_simu$y,col=c("#ff4444","#44ff44")[sol@cl])
sol=fit_greed_cond(new("mreg",alpha=1,a0=1,b0=1,reg=1),mreg_simu$X,mreg_simu$y,5,verbose = TRUE)
plot(mreg_simu$X[,1],mreg_simu$y,col=c("#ff4444","#44ff44")[sol@cl])
sol=fit_greed_cond(new("mreg",alpha=1,a0=1,b0=1,reg=1),mreg_simu$X,mreg_simu$y,5,verbose = TRUE)
sol=fit_greed_cond(new("mreg",alpha=1,a0=1,b0=1,reg=1),mreg_simu$X,mreg_simu$y,5)
plot(sol)
plot(sol,type='tree')
sol@path
sol=fit_greed_cond(new("mreg",alpha=1,a0=1,b0=1,reg=1),mreg_simu$X,mreg_simu$y,5)
hybrid = function(f,fi, K,model,alg,verbose=FALSE){
train.hist = data.frame(generation=c(),icl=c(),K=c())
# multi-start in //
#future::plan(future::multiprocess)
solutions = listenv::listenv()
# first generation of solutions
pop_size = alg@pop_size
for (i in 1:pop_size){
solutions[[i]] %<-% f(model,x,K,verbose=verbose)
}
solutions = as.list(solutions)
icls  = sapply(solutions,function(s){s@icl})
# check for errors
solutions=solutions[!is.nan(icls)]
icls=icls[!is.nan(icls)]
old_best = -Inf
best_icl = max(icls)
nbgen = 1
# while maximum number of generation // all solutions are equals // no improvements
while((max(icls)-min(icls))>1 & (best_icl > old_best) & nbgen < alg@nb_max_gen){
train.hist=rbind(train.hist,data.frame(generation=nbgen,icl=icls,K=sapply(solutions,function(s){max(s@cl)})))
# selection keep the top half solutions
icl_order = order(icls,decreasing = TRUE)
selected  = icl_order[1:(pop_size/2)]
# cross_over between the kept solution
new_solutions = listenv::listenv()
selected_couples = matrix(selected[sample(1:length(selected),length(selected)*2,replace = TRUE)],ncol=2)
for (i in 1:nrow(selected_couples)){
new_solutions[[i]] %<-% full_cross_over(solutions[[selected_couples[i,1]]],solutions[[selected_couples[i,2]]],model,x,verbose)
}
new_solutions = as.list(new_solutions)
solutions = c(solutions[selected],new_solutions)
icls = sapply(solutions,function(s){s@icl})
old_best=best_icl
best_icl = max(icls)
nbgen = nbgen + 1;
}
train.hist=rbind(train.hist,data.frame(generation=nbgen,icl=icls,K=sapply(solutions,function(s){max(s@cl)})))
#parallel::stopCluster(cl)
# best solution
res = solutions[[order(icls,decreasing = TRUE)[1]]]
# compute merge path
path = fit_greed_path(x,res)
# clean the resuts (compute, merge tree,...)
path = cleanpath(path)
# store train history
path@train_hist = train.hist
# stop future plan
#oplan <- future::plan()
#on.exit(future::plan(oplan), add = TRUE)
path
})
full_cross_over = function(sol1,sol2,model,x,verbose){
# cartesian product on the z of the two solution
ncl = unclass(factor(paste(sol1@cl,sol2@cl)))
# greedy merge
fi(model,x,ncl,"merge",verbose=verbose)
}
hybrid = function(f,fi, K,model,alg,verbose=FALSE){
train.hist = data.frame(generation=c(),icl=c(),K=c())
# multi-start in //
#future::plan(future::multiprocess)
solutions = listenv::listenv()
# first generation of solutions
pop_size = alg@pop_size
for (i in 1:pop_size){
solutions[[i]] %<-% f(model,x,K,verbose=verbose)
}
solutions = as.list(solutions)
icls  = sapply(solutions,function(s){s@icl})
# check for errors
solutions=solutions[!is.nan(icls)]
icls=icls[!is.nan(icls)]
old_best = -Inf
best_icl = max(icls)
nbgen = 1
# while maximum number of generation // all solutions are equals // no improvements
while((max(icls)-min(icls))>1 & (best_icl > old_best) & nbgen < alg@nb_max_gen){
train.hist=rbind(train.hist,data.frame(generation=nbgen,icl=icls,K=sapply(solutions,function(s){max(s@cl)})))
# selection keep the top half solutions
icl_order = order(icls,decreasing = TRUE)
selected  = icl_order[1:(pop_size/2)]
# cross_over between the kept solution
new_solutions = listenv::listenv()
selected_couples = matrix(selected[sample(1:length(selected),length(selected)*2,replace = TRUE)],ncol=2)
for (i in 1:nrow(selected_couples)){
new_solutions[[i]] %<-% full_cross_over(solutions[[selected_couples[i,1]]],solutions[[selected_couples[i,2]]],model,x,verbose)
}
new_solutions = as.list(new_solutions)
solutions = c(solutions[selected],new_solutions)
icls = sapply(solutions,function(s){s@icl})
old_best=best_icl
best_icl = max(icls)
nbgen = nbgen + 1;
}
train.hist=rbind(train.hist,data.frame(generation=nbgen,icl=icls,K=sapply(solutions,function(s){max(s@cl)})))
#parallel::stopCluster(cl)
# best solution
res = solutions[[order(icls,decreasing = TRUE)[1]]]
# compute merge path
path = fit_greed_path(x,res)
# clean the resuts (compute, merge tree,...)
path = cleanpath(path)
# store train history
path@train_hist = train.hist
# stop future plan
#oplan <- future::plan()
#on.exit(future::plan(oplan), add = TRUE)
path
}
hybrid = function(f,fi, K,model,alg,verbose=FALSE){
train.hist = data.frame(generation=c(),icl=c(),K=c())
# multi-start in //
#future::plan(future::multiprocess)
solutions = listenv::listenv()
# first generation of solutions
pop_size = alg@pop_size
for (i in 1:pop_size){
solutions[[i]] %<-% f(model,K,verbose=verbose)
}
solutions = as.list(solutions)
icls  = sapply(solutions,function(s){s@icl})
# check for errors
solutions=solutions[!is.nan(icls)]
icls=icls[!is.nan(icls)]
old_best = -Inf
best_icl = max(icls)
nbgen = 1
# while maximum number of generation // all solutions are equals // no improvements
while((max(icls)-min(icls))>1 & (best_icl > old_best) & nbgen < alg@nb_max_gen){
train.hist=rbind(train.hist,data.frame(generation=nbgen,icl=icls,K=sapply(solutions,function(s){max(s@cl)})))
# selection keep the top half solutions
icl_order = order(icls,decreasing = TRUE)
selected  = icl_order[1:(pop_size/2)]
# cross_over between the kept solution
new_solutions = listenv::listenv()
selected_couples = matrix(selected[sample(1:length(selected),length(selected)*2,replace = TRUE)],ncol=2)
for (i in 1:nrow(selected_couples)){
new_solutions[[i]] %<-% full_cross_over(solutions[[selected_couples[i,1]]],solutions[[selected_couples[i,2]]],model,x,verbose)
}
new_solutions = as.list(new_solutions)
solutions = c(solutions[selected],new_solutions)
icls = sapply(solutions,function(s){s@icl})
old_best=best_icl
best_icl = max(icls)
nbgen = nbgen + 1;
}
train.hist=rbind(train.hist,data.frame(generation=nbgen,icl=icls,K=sapply(solutions,function(s){max(s@cl)})))
#parallel::stopCluster(cl)
# best solution
res = solutions[[order(icls,decreasing = TRUE)[1]]]
# compute merge path
path = fit_greed_path(x,res)
# clean the resuts (compute, merge tree,...)
path = cleanpath(path)
# store train history
path@train_hist = train.hist
# stop future plan
#oplan <- future::plan()
#on.exit(future::plan(oplan), add = TRUE)
path
}
hybrid = function(f,fi, K,model,alg,verbose=FALSE){
train.hist = data.frame(generation=c(),icl=c(),K=c())
# multi-start in //
#future::plan(future::multiprocess)
solutions = listenv::listenv()
# first generation of solutions
pop_size = alg@pop_size
for (i in 1:pop_size){
solutions[[i]] %<-% f(model,K,verbose=verbose)
}
solutions = as.list(solutions)
icls  = sapply(solutions,function(s){s@icl})
# check for errors
solutions=solutions[!is.nan(icls)]
icls=icls[!is.nan(icls)]
old_best = -Inf
best_icl = max(icls)
nbgen = 1
# while maximum number of generation // all solutions are equals // no improvements
while((max(icls)-min(icls))>1 & (best_icl > old_best) & nbgen < alg@nb_max_gen){
train.hist=rbind(train.hist,data.frame(generation=nbgen,icl=icls,K=sapply(solutions,function(s){max(s@cl)})))
# selection keep the top half solutions
icl_order = order(icls,decreasing = TRUE)
selected  = icl_order[1:(pop_size/2)]
# cross_over between the kept solution
new_solutions = listenv::listenv()
selected_couples = matrix(selected[sample(1:length(selected),length(selected)*2,replace = TRUE)],ncol=2)
for (i in 1:nrow(selected_couples)){
new_solutions[[i]] %<-% full_cross_over(solutions[[selected_couples[i,1]]],solutions[[selected_couples[i,2]]],model,x,verbose)
}
new_solutions = as.list(new_solutions)
solutions = c(solutions[selected],new_solutions)
icls = sapply(solutions,function(s){s@icl})
old_best=best_icl
best_icl = max(icls)
nbgen = nbgen + 1;
}
train.hist=rbind(train.hist,data.frame(generation=nbgen,icl=icls,K=sapply(solutions,function(s){max(s@cl)})))
#parallel::stopCluster(cl)
# best solution
res = solutions[[order(icls,decreasing = TRUE)[1]]]
# compute merge path
path = fit_greed_path(x,res)
# clean the resuts (compute, merge tree,...)
path = cleanpath(path)
# store train history
path@train_hist = train.hist
# stop future plan
#oplan <- future::plan()
#on.exit(future::plan(oplan), add = TRUE)
path
}
full_cross_over = function(sol1,sol2,model,x,verbose){
# cartesian product on the z of the two solution
ncl = unclass(factor(paste(sol1@cl,sol2@cl)))
# greedy merge
fi(model,ncl,"merge",verbose=verbose)
}
X=mreg_simu$X
y=mreg_simu$y
f = function(model,k,verb){
fit_greed_cond(model,X,y,k,verb)
}
fi = function(model,cl,k,verb){
fit_greed_init_cond(model,X,y,cl,verb)
}
hybrid = function(f,fi, K,model,verbose=FALSE){
train.hist = data.frame(generation=c(),icl=c(),K=c())
# multi-start in //
#future::plan(future::multiprocess)
solutions = listenv::listenv()
# first generation of solutions
pop_size = alg@pop_size
for (i in 1:pop_size){
solutions[[i]] %<-% f(model,K,verbose=verbose)
}
solutions = as.list(solutions)
icls  = sapply(solutions,function(s){s@icl})
# check for errors
solutions=solutions[!is.nan(icls)]
icls=icls[!is.nan(icls)]
old_best = -Inf
best_icl = max(icls)
nbgen = 1
# while maximum number of generation // all solutions are equals // no improvements
while((max(icls)-min(icls))>1 & (best_icl > old_best) & nbgen < alg@nb_max_gen){
train.hist=rbind(train.hist,data.frame(generation=nbgen,icl=icls,K=sapply(solutions,function(s){max(s@cl)})))
# selection keep the top half solutions
icl_order = order(icls,decreasing = TRUE)
selected  = icl_order[1:(pop_size/2)]
# cross_over between the kept solution
new_solutions = listenv::listenv()
selected_couples = matrix(selected[sample(1:length(selected),length(selected)*2,replace = TRUE)],ncol=2)
for (i in 1:nrow(selected_couples)){
new_solutions[[i]] %<-% full_cross_over(solutions[[selected_couples[i,1]]],solutions[[selected_couples[i,2]]],model,x,verbose)
}
new_solutions = as.list(new_solutions)
solutions = c(solutions[selected],new_solutions)
icls = sapply(solutions,function(s){s@icl})
old_best=best_icl
best_icl = max(icls)
nbgen = nbgen + 1;
}
train.hist=rbind(train.hist,data.frame(generation=nbgen,icl=icls,K=sapply(solutions,function(s){max(s@cl)})))
#parallel::stopCluster(cl)
# best solution
res = solutions[[order(icls,decreasing = TRUE)[1]]]
# compute merge path
path = fit_greed_path(x,res)
# clean the resuts (compute, merge tree,...)
path = cleanpath(path)
# store train history
path@train_hist = train.hist
# stop future plan
#oplan <- future::plan()
#on.exit(future::plan(oplan), add = TRUE)
path
}
hybrid(f,fi,5,new("mreg"))
hybrid = function(f,fi, K,alg,model,verbose=FALSE){
train.hist = data.frame(generation=c(),icl=c(),K=c())
# multi-start in //
#future::plan(future::multiprocess)
solutions = listenv::listenv()
# first generation of solutions
pop_size = alg@pop_size
for (i in 1:pop_size){
solutions[[i]] %<-% f(model,K,verbose=verbose)
}
solutions = as.list(solutions)
icls  = sapply(solutions,function(s){s@icl})
# check for errors
solutions=solutions[!is.nan(icls)]
icls=icls[!is.nan(icls)]
old_best = -Inf
best_icl = max(icls)
nbgen = 1
# while maximum number of generation // all solutions are equals // no improvements
while((max(icls)-min(icls))>1 & (best_icl > old_best) & nbgen < alg@nb_max_gen){
train.hist=rbind(train.hist,data.frame(generation=nbgen,icl=icls,K=sapply(solutions,function(s){max(s@cl)})))
# selection keep the top half solutions
icl_order = order(icls,decreasing = TRUE)
selected  = icl_order[1:(pop_size/2)]
# cross_over between the kept solution
new_solutions = listenv::listenv()
selected_couples = matrix(selected[sample(1:length(selected),length(selected)*2,replace = TRUE)],ncol=2)
for (i in 1:nrow(selected_couples)){
new_solutions[[i]] %<-% full_cross_over(solutions[[selected_couples[i,1]]],solutions[[selected_couples[i,2]]],model,x,verbose)
}
new_solutions = as.list(new_solutions)
solutions = c(solutions[selected],new_solutions)
icls = sapply(solutions,function(s){s@icl})
old_best=best_icl
best_icl = max(icls)
nbgen = nbgen + 1;
}
train.hist=rbind(train.hist,data.frame(generation=nbgen,icl=icls,K=sapply(solutions,function(s){max(s@cl)})))
#parallel::stopCluster(cl)
# best solution
res = solutions[[order(icls,decreasing = TRUE)[1]]]
# compute merge path
path = fit_greed_path(x,res)
# clean the resuts (compute, merge tree,...)
path = cleanpath(path)
# store train history
path@train_hist = train.hist
# stop future plan
#oplan <- future::plan()
#on.exit(future::plan(oplan), add = TRUE)
path
}
hybrid(f,fi,5,new("hybrid"),new("mreg"))
library(future)
hybrid(f,fi,5,new("hybrid"),new("mreg"))
hybrid(f,fi,5,new("hybrid"),new("mreg"),TRUE)
f(new("mreg"),5,TRUE)
f(new("mreg"),5)
f(new("mreg"),5,TRUE)
X=mreg_simu$X
y=mreg_simu$y
f = function(model,k,verb){
fit_greed_cond(model,X,y,k,verb)
}
f(new("mreg"),5,TRUE)
X
X=mreg_simu$X
y=mreg_simu$y
f = function(model,k,verb){
fit_greed_cond(model,X,y,k,verbose=verb)
}
fi = function(model,cl,k,verb){
fit_greed_init_cond(model,X,y,cl,verbose=verb)
}
f(new("mreg"),5,TRUE)
f(new("mreg"),5,TRUE)
devtools::document()
library(greed)
library(Matrix)
library(ggplot2)
N=1500
K=15
pi=rep(1/K,K)
lambda  = 0.1
lambda_o = 0.01
Ks=5
mu = bdiag(lapply(1:(K/Ks), function(k){matrix(lambda_o,Ks,Ks)+diag(rep(lambda,Ks))}))+0.001
sbm = rsbm(N,pi,mu)
sol = fit(sbm$x,25)
library(greed)
sol = fit(sbm$x,25)
